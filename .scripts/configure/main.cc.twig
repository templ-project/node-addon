#ifndef BUILDING_NODE_EXTENSION
#define BUILDING_NODE_EXTENSION
#endif

{% if api == 'nan' %}

#define if_unmet_throw(call, thrower, error)                               \
  if (!(call)) {                                                               \
    thrower(error);                                                            \
  }

#include <nan.h>
#include <node.h>
#include <v8.h>

void Hello(const Nan::FunctionCallbackInfo<v8::Value>& info) {
  v8::Isolate* isolate = info.GetIsolate();
  v8::Local<v8::Context> context = isolate->GetCurrentContext();
  v8::Local<v8::String> who;

  if (info.Length() < 1) {
    if_unmet_throw(
        Nan::New("World").ToLocal(&who), Nan::ThrowError, "unable to allocate")
  } else {
    if_unmet_throw(info[0]->IsString(),
                       Nan::ThrowTypeError,
                       "Invalid argument type; expecting string.")
        if_unmet_throw(info[0]->ToString(context).ToLocal(&who),
                           Nan::ThrowRangeError,
                           "could not read arguments")
  }

  v8::Local<v8::String> hello;
  if_unmet_throw(
      Nan::New("Hello ").ToLocal(&hello), Nan::ThrowError, "unable to allocate")

      v8::Local<v8::String>
          em;
  if_unmet_throw(
      Nan::New("!").ToLocal(&em), Nan::ThrowError, "unable to allocate")

      hello = v8::String::Concat(isolate, hello, who);
  hello = v8::String::Concat(isolate, hello, em);

  info.GetReturnValue().Set(hello);
}

void Init(v8::Local<v8::Object> exports,
          v8::Local<v8::Value> /*module*/,
          void* /*priv*/) {
  v8::Local<v8::Context> context = exports->CreationContext();
  bool hasConverted = true;
  if_unmet_throw(exports
                         ->Set(context,
                               Nan::New("hello").ToLocalChecked(),
                               Nan::New<v8::FunctionTemplate>(Hello)
                                   ->GetFunction(context)
                                   .ToLocalChecked())
                         .To(&hasConverted),
                     Nan::ThrowError,
                     "unable to determine the map of 'hello' method");
  if_unmet_throw(
      hasConverted, Nan::ThrowError, "unable to map 'hello' method")
}

NODE_MODULE(hello, Init)
{% elseif api == 'napi' %}
#include <assert.h>
#include <node_api.h>

static napi_value Method(napi_env env, napi_callback_info info) {
  napi_status status;
  napi_value world;
  status = napi_create_string_utf8(env, "world", 5, &world);
  assert(status == napi_ok);
  return world;
}

#define DECLARE_NAPI_METHOD(name, func)                                        \
  { name, 0, func, 0, 0, 0, napi_default, 0 }

static napi_value Init(napi_env env, napi_value exports) {
  napi_status status;
  napi_property_descriptor desc = DECLARE_NAPI_METHOD("hello", Method);
  status = napi_define_properties(env, exports, 1, &desc);
  assert(status == napi_ok);
  return exports;
}

NAPI_MODULE(hello, Init)
{% else %}

#define if_unmet_throw(call, thrower, error)                                   \
  if (!(call)) {                                                               \
    thrower::New(env, error).ThrowAsJavaScriptException();                     \
  }

#include <napi.h>

Napi::String Method(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  std::string result = "Hello ";

  if (info.Length() < 1) {
    result += "World";
  } else {
    if_unmet_throw(info[0].IsString(),
                       Napi::TypeError,
                       "Invalid argument type; expecting string.")

        result += info[0].As<Napi::String>().Utf8Value();
  }

  result += "!";

  return Napi::String::New(env, result);
}

Napi::Object Init(Napi::Env env, Napi::Object exports) {
  exports.Set(Napi::String::New(env, "hello"),
              Napi::Function::New(env, Method));
  return exports;
}

NODE_API_MODULE(hello, Init)
{% endif %}
